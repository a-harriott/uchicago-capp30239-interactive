<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ally's Interactive Project</title>

    <!-- MapLibre GL css -->
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />

    <!-- My stylesheet -->
    <link rel="stylesheet" href="stylesheets/custom.css" />
</head>

<body>
    
    <header>
        <h1>Investigating Key Features of New York State School Districts</h1>
    </header>

    <main class="app">

        <div class="toolbar">

            <label for="metric">Metric</label>
            <select id="metric">
                <option value="pupil_teacher" selected>Pupil per Teacher Ratio</option>
                <option value="revenue_pupil">Total Revenue per Pupil</option>
                <option value="expenditure_pupil">Total Expenditure per Pupil</option>
                <option value="grad_rate">Graduation Rate</option>
            </select>

            <label for="year">Year</label>
            <select id="year">
                <option value="2021-22">2021-22</option>
                <option value="2020-21">2020-21</option>
                <option value="2019-20">2019-20</option>
                <option value="2018-19">2018-19</option>
                <option value="2017-18">2017-18</option>
                <option value="2016-17">2016-17</option>
                <option value="2015-16">2015-16</option>
                <option value="2014-15">2014-15</option>
                <option value="2013-14">2013-14</option>
                <option value="2012-13">2012-13</option>
                <option value="2011-12">2011-12</option>
            </select>
        </div>

        <div class="map-table-grid">
            
            <div class="map-column">
                <div id="map"></div>

                <div id="map-legend" class="map-legend-panel"></div>
            </div>

            <div class="table-panel">

                <div class="table-header">
                    <h3 id="table-title">School Districts</h3>
                    <div class="legend" id="legend"></div>
                </div>

                <!-- Scrollable table wrapper -->
                <div style="overflow:auto;">

                    <table id="data-table">
                        <thead>
                            <tr>
                                <th>School District</th>
                                <th>Year</th>
                                <th>Value</th>
                            </tr>
                        </thead>

                        <tbody></tbody>

                    </table>

                </div>
            </div>
        </div>

        <!-- Line chart -->
        <div class="chart-panel">
            <div class="chart-header">
                <h3 id="chart-title">Trend Over Time</h3>
            </div>
            <div id="linechart"></div>
        </div>
    </main>

    <!-- Load MapLibre GL -->
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

    <!-- Load D3 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        // Make the map base layer
        const map = new maplibregl.Map({
            container: 'map',  // The id of the map <div>
            style: 'https://demotiles.maplibre.org/style.json', // file describes which tile sources to use and how to render them
            center: [-73.7, 40.7],  // NY area center
            zoom: 5
        });

        // Add zoom/rotation controls
        map.addControl(new maplibregl.NavigationControl());

        // Color palette for choropleth
        const uniform_palette = ['#edf2fb','#c1d3fe','#a9c1ff','#7da2fa','#4f7cf3','#2f57d9'];

        // Dropdowns at top of page
        const metricSel = document.getElementById('metric');
        const yearSel = document.getElementById('year');

        // Keep track of clicked districts
        let selectedDistricts = [];

        // function to catch empty strings from csv
        // need this because empty strings -> 0 when coerced to numeric with +x
        function keepNull(x) {
            if (x === "") {
                return null;
            } else {
                return +x;
                }
        }
        // same function just shorthand
        //function keepNull(x) {
        //    return (x === "") ? null : +x;
        //}

        // make sure to put "NA" instead of "null" for popup
        function showNullAsNa(entry, metric) {
            // First check if the entry object exists
            if (entry) {
                // Check if metric value is null
                if (entry[metric] == null) {
                return "NA";
                } else {
                return entry[metric];
                }
            } else {
                // If the entry itself doesn't exist in the data, return "NA"
                return "NA";
            }
        }

        function displayFormat(value, metric) {
            // NA stays NA
            if (value === "NA") return "NA";

            // Monetary metrics: add $ and commas, no decimals
            if (metric.includes("revenue") || metric.includes("expenditure")) {
                return "$" + d3.format(",")(Math.round(value));
            }

            // Percent metrics: whole number + %
            if (metric.includes("rate")) {
                return d3.format(".0f")(value) + "%";
            }

            // Ratio for pupil_teacher
            if (metric === "pupil_teacher") {
                return d3.format(".1f")(value);
            }

            // Default: just show raw value
            return value;
        }

        // Putting things on the map
        map.on('load', () => {
            // Use D3 to load the geojson and csv
            const districts = d3.json('data/NYS_Schools_3089706237687211859.geojson');
            const metrics = d3.csv('data/interactive_data_v2.csv', (d) => {
                return {
                    year: d.year,
                    district: d.district,
                    county: d.county,
                    locale_group: d.locale_group,
                    highest_grade: d.highest_grade,
                    enrollment: keepNull(d.enrollment),
                    pupil_teacher: keepNull(d.pupil_teacher),
                    revenue: keepNull(d.revenue),
                    revenue_local: keepNull(d.revenue_local),
                    revenue_state: keepNull(d.revenue_state),
                    revenue_federal: keepNull(d.revenue_federal),
                    revenue_pupil: keepNull(d.revenue_pupil),
                    revenue_local_pupil: keepNull(d.revenue_local_pupil),
                    revenue_state_pupil: keepNull(d.revenue_state_pupil),
                    revenue_federal_pupil: keepNull(d.revenue_pupil),
                    expenditure: keepNull(d.expenditure),
                    expenditure_pupil: keepNull(d.expenditure_pupil),
                    expenditure_instruction_pupil: keepNull(d.expenditure_instruction_pupil),
                    expenditure_support_pupil: keepNull(d.expenditure_support_pupil),
                    nces_id: d.nces_id,
                    SED_CODE_1: d.SED_CODE_1,
                    grad_rate: keepNull(d.grad_rate*100),
                    ard_rate: keepNull(d.ard_rate*100) 
                }
            });

            // Wait until the files are loaded
            Promise.all([metrics, districts]).then(([metricsCSV, districtsGeojson]) => {
                // build dictionary for metrics
                const metricsDict = {};

                metricsCSV.forEach(d => {
                    const id = d.SED_CODE_1;
                    const year = d.year;

                    if (!metricsDict[id]) {
                        metricsDict[id] = {};   // initialize dictionary for this district
                    }

                    metricsDict[id][year] = {
                        district: d.district,
                        county: d.county,
                        locale_group: d.locale_group,
                        highest_grade: d.highest_grade,
                        enrollment: d.enrollment,
                        pupil_teacher: d.pupil_teacher,
                        revenue: d.revenue,
                        revenue_local: d.revenue_local,
                        revenue_state: d.revenue_state,
                        revenue_federal: d.revenue_federal,
                        revenue_pupil: d.revenue_pupil,
                        revenue_local_pupil: d.revenue_local_pupil,
                        revenue_state_pupil: d.revenue_state_pupil,
                        revenue_federal_pupil: d.revenue_federal_pupil,
                        expenditure: d.expenditure,
                        expenditure_pupil: d.expenditure_pupil,
                        expenditure_instruction_pupil: d.expenditure_instruction_pupil,
                        expenditure_support_pupil: d.expenditure_support_pupil,
                        grad_rate: d.grad_rate,
                        ard_rate: d.ard_rate
                    };
                });
                console.log(metricsDict);

                // Add the school districts from the geojson to the map
                map.addSource('schoolDistricts', {
                    type: 'geojson',
                    data: districtsGeojson
                });

                // Add a fill layer (choropleth polygons)
                map.addLayer({
                    id: 'schoolDistricts-fill',
                    type: 'fill',
                    source: 'schoolDistricts',
                    paint: {
                        //'fill-color': '#88c',
                        'fill-color': ['get', 'color'],
                        'fill-opacity': 1
                    }
                });

                // Add an outline layer (borders)
                map.addLayer({
                    id: 'schoolDistricts-outline',
                    type: 'line',
                    source: 'schoolDistricts',
                    paint: {
                    'line-color': '#000',
                    'line-width': 1
                    }
                });

                // Create a popup object (no close button, no click required)
                const popup = new maplibregl.Popup({
                    closeButton: false,
                    closeOnClick: false
                });

                map.on('mousemove', 'schoolDistricts-fill', function(e) {
                    const metric = metricSel.value; // selected from dropdown
                    const metricLabel = metricSel.options[metricSel.selectedIndex].text; 
                    const year = yearSel.value; // selected from dropdown
                    const f = e.features[0];
                    const id = f.properties.SED_CODE_1;

                    // Lookup in metricsDict
                    const entry = metricsDict[id] && metricsDict[id][year];
                    const districtName = entry ? entry.district: "Unknown";
                    const countyName = entry ? entry.county: "Unknown";
                    const localeName = entry ? entry.locale_group: "Unknown";
                    const value = showNullAsNa(entry, metric);
                    const displayValue = displayFormat(value, metric);

                    // What will be within the popup
                    popup.setLngLat(e.lngLat)
                        .setHTML("<b>" + districtName + "</b><br>" +
                            metricLabel + " (" + year + "): " + displayValue + 
                            "<br>" +
                            "Locale: " + localeName +
                            "<br>" +
                            "County: " + countyName)
                        .addTo(map);
                });

                // Remove popup when leaving
                map.on('mouseleave', 'schoolDistricts-fill', function() {
                    popup.remove();
                });

                // Add a clicked sitrict to the table
                map.on('click', 'schoolDistricts-fill', (e) => {
                    const metric = metricSel.value;
                    const metricLabel = metricSel.options[metricSel.selectedIndex].text;
                    const year = yearSel.value;
                    const feature = e.features[0];
                    const id = feature.properties.SED_CODE_1; // or nces_id

                    // Check if already selected
                    const alreadySelected = selectedDistricts.some(
                        f => f.id === id && f.year === year
                    );

                    if (!alreadySelected) {
                        // Track the district and year
                        selectedDistricts.push({ id, year });
                    }

                    // Update the table with all selected districts
                    updateTable(selectedDistricts, metric, year, metricsDict);

                    // Update the line chart
                    updateLineChart(id, metric, metricsDict, metricLabel);

                });

                renderAll(districtsGeojson, metricsDict)

                metricSel.addEventListener('change', () => {
                    renderAll(map.getSource('schoolDistricts')._data, metricsDict);
                });

                    yearSel.addEventListener('change', () => {
                    renderAll(map.getSource('schoolDistricts')._data, metricsDict);
                });

            });
        });

        // Table update - on click
        function updateTable(selectedDistricts, metric, year, metricsDict) {
            const tbody = document.querySelector('#data-table tbody');
            const title = document.getElementById('table-title');
            const metricLabel = metricSel.options[metricSel.selectedIndex].text;
            title.textContent = `Selected Districts — ${metricLabel}`;
            tbody.innerHTML = '';

            selectedDistricts.forEach(sel => {
                const entry = metricsDict[sel.id] && metricsDict[sel.id][sel.year];
                const districtName = entry ? entry.district: "Unknown";
                const value = showNullAsNa(entry, metric);
                const displayValue = displayFormat(value, metric)

                const tr = document.createElement('tr');

                const tdKey = document.createElement('td');
                tdKey.textContent = districtName;

                const tdYear = document.createElement('td');
                tdYear.textContent = sel.year;

                const tdValue = document.createElement('td');
                tdValue.textContent = displayValue;

                tr.appendChild(tdKey);
                tr.appendChild(tdYear);
                tr.appendChild(tdValue);
                tbody.appendChild(tr);
            });
        }

        // Function to get choropleth palette
        function getPalette(metric) {
            const my_blue_palette = [
                "#e3f2fd", // very light blue
                "#90caf9", // light
                "#42a5f5", // medium
                "#1976d2", // dark
                "#0d47a1"  // very dark
            ];

            const my_green_palette = [
                "#e8f5e9", // very light green
                "#a5d6a7", // light
                "#66bb6a", // medium
                "#388e3c", // dark
                "#1b5e20"  // very dark
            ];

            const my_orange_palette = [
                "#fff3e0", // very light orange
                "#ffcc80", // light
                "#fb8c00", // medium
                "#ef6c00", // dark
                "#e65100"  // very dark
            ]

            const my_purple_palette = [
                "#f3e5f5", // very light purple
                "#ce93d8", // light
                "#ab47bc", // medium
                "#7b1fa2", // dark
                "#4a148c"  // very dark
            ]

            if (metric === "pupil_teacher") return my_blue_palette;
            if (metric === "revenue_pupil") return my_green_palette;
            if (metric === "expenditure_pupil") return my_orange_palette;
            if (metric === "grad_rate") return my_purple_palette;
        }

        function renderAll(geojson, metricsDict) {
            const metric = metricSel.value;
            const metricLabel = metricSel.options[metricSel.selectedIndex].text;
            const year = yearSel.value;

            // Collect values for chosen year
            let values = [];
            geojson.features.forEach(f => {
                const id = f.properties.SED_CODE_1;
                const entry = metricsDict[id] && metricsDict[id][year];
                // skip null values
                if (entry && entry[metric] != null) {
                values.push(entry[metric]);
                }
            });

            // color palette
            //const min = Math.min(...values);
            //const max = Math.max(...values);

            const palette = getPalette(metric);
            //const colorScale = d3.scaleQuantize()
            //.domain([min, max])
            const colorScale = d3.scaleQuantile()
            .domain(values)
            .range(palette);
            
            //const colorScale = d3.scaleQuantize()
            //.domain([min, max])
            //.range(uniform_palette);

            // Get legend
            updateLegend(colorScale, metric);

            // Assign colors based on dictionary values
            geojson.features.forEach(f => {
                const id = f.properties.SED_CODE_1;
                const entry = metricsDict[id] && metricsDict[id][year];
                const v = entry ? entry[metric] : null;

                // turn gray if metric is null
                f.properties.color = v == null ? "#8a8a8a" : colorScale(v);
            });

            console.log("Metric:", metric, "Year:", year);
            console.log("Values collected:", values);
            //console.log("Min:", min, "Max:", max);    

            // Update source
            map.getSource('schoolDistricts').setData(geojson);

            // Update table with selected districts (if any)
            updateTable(selectedDistricts, metric, year, metricsDict);
        }

        // Legend
        function updateLegend(colorScale, metric) {
            const legend = d3.select("#map-legend");
            legend.selectAll("*").remove(); // clear old legend

            const thresholds = colorScale.quantiles ? colorScale.quantiles() : colorScale.thresholds();
            const range = colorScale.range();

            // Build swatches
            range.forEach((color, i) => {
                const swatch = legend.append("div").attr("class", "map-legend-swatch").style("background", color);

                let label;
                if (i === 0) {
                    label = `≤ ${displayFormat(thresholds[0], metric)}`;
                } else if (i === range.length - 1) {
                    label = `≥ ${displayFormat(thresholds[thresholds.length - 1], metric)}`;
                } else {
                    label = `${displayFormat(thresholds[i-1], metric)} – ${displayFormat(thresholds[i], metric)}`;
                }

                legend.append("span").text(label);
            });

            // Add "No data" swatch
            legend.append("div").attr("class", "map-legend-swatch").style("background", "#8a8a8a");
            legend.append("span").text("No data");
        }

        // Line chart
        function getAverageTrend(metric, metricsDict) {
            // Collect all years
            const years = Object.keys(metricsDict[Object.keys(metricsDict)[0]]);
            
            return years.map(year => {
                const values = Object.values(metricsDict)
                .map(d => d[year]?.[metric])
                .filter(v => v !== undefined && v !== "NA");
                const avg = d3.mean(values);
                return { year, value: avg };
            });
        }

        function getTimeSeriesData(id, metric, metricsDict) {
            const entries = metricsDict[id];
            if (!entries) return [];
            return Object.keys(entries).map(year => ({
                year: year,
                value: entries[year][metric]
            })).sort((a, b) => d3.ascending(a.year, b.year));
        }

        function updateLineChart(id, metric, metricsDict, metricLabel) {
            const data = getTimeSeriesData(id, metric, metricsDict);
            const avgData = getAverageTrend(metric, metricsDict);

            // Clear old chart
            d3.select("#linechart").selectAll("*").remove();

            const container = document.getElementById("linechart");
            svgHeight = 300;
            //const svgWidth = 600;
            const svgWidth = container.offsetWidth * 0.8 + 200; // add space for legend
            const containerWidth = container.offsetWidth;

            const margin = { top: 30, right: 150, bottom: 40, left: 75 };

            const svg = d3.select("#linechart")
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .style("background", "var(--panel)")
                .style("border", "1px solid var(--border)")
                .style("border-radius", "10px");

            const chartWidth = svgWidth - margin.left - margin.right;
            const chartHeight = svgHeight - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Scaling
            const x = d3.scalePoint()
                .domain(data.map(d => d.year))
                .range([0, chartWidth]);

            const yMin = d3.min([
            d3.min(data, d => d.value),
            d3.min(avgData, d => d.value)
            ]);

            const yMax = d3.max([
            d3.max(data, d => d.value),
            d3.max(avgData, d => d.value)
            ]);

            const y = d3.scaleLinear()
            .domain([yMin, yMax])
            .nice()
            .range([chartHeight, 0]);

            // Axes
            g.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .style("fill", "var(--muted)")
                .style("font-size", "12px");

            g.append("g")
                .attr("class", "y-axis")
                .call(d3.axisLeft(y)
                    .tickFormat(d => displayFormat(d, metric)))
                .selectAll("text")
                .style("fill", "var(--muted)")
                .style("font-size", "12px");

            g.selectAll(".domain, .tick line")
                .style("stroke", "var(--border)");

            // Axis labels
            // X axis label
            svg.append("text")
            .attr("class", "x label")
            .attr("text-anchor", "middle")
            .attr("x", margin.left + chartWidth / 2)   // center under the chart
            .attr("y", svgHeight - 5)                  // a little below the x-axis
            .style("font-size", "12px")
            .style("fill", "var(--muted)")
            .style("font-weight", "bold")
            .text("Year");

            // Y axis label
            svg.append("text")
            .attr("class", "y label")
            .attr("text-anchor", "middle")
            .attr("transform", `rotate(-90)`)
            .attr("x", -(margin.top + chartHeight / 2)) // center along y-axis
            .attr("y", 15)                              // a little left of the y-axis
            .style("font-size", "12px")
            .style("fill", "var(--muted)")
            .style("font-weight", "bold")
            .text(metricLabel);

            // Title
            const entry = Object.values(metricsDict[id])[0];  // first year’s entry object
            const districtName = entry ? entry.district : "Unknown";
            svg.append("text")
                .attr("x", containerWidth / 2)
                .attr("y", margin.top - 5)
                .attr("text-anchor", "middle") 
                .attr("fill", "var(--text)")
                .style("font-size", "14px")
                .style("font-weight", "600")
                .text(`Trend for ${metricLabel} (${districtName}) vs School District Average`);

            // District line generator
            const line = d3.line()
                .x(d => x(d.year))
                .y(d => y(d.value));

            // District draw line
            const lineColor = getPalette(metric)[2];
            g.append("path")
                .datum(data)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", lineColor)
                .attr("stroke-width", 2)
                .attr("d", line);

            // District add dots
            g.selectAll(".dot")
            .data(data)
            .enter()
            .append("circle")
            .attr("class", "dot")
            .attr("cx", d => x(d.year))
            .attr("cy", d => y(d.value))
            .attr("r", 4)
            .attr("fill", lineColor)
            .attr("stroke", "#fff")
            .attr("stroke-width", 1.5);

            // Average line
            const avgLine = d3.line()
            .x(d => x(d.year))
            .y(d => y(d.value));

            g.append("path")
            .datum(avgData)
            .attr("class", "avg-line")
            .attr("fill", "none")
            .attr("stroke", "#444") 
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5,5") // dashed
            .attr("d", avgLine);

            // Legend for lines
            const legend = svg.append("g")
            .attr("class", "chartline-legend")
            .attr("transform", `translate(${chartWidth + margin.left + 20}, ${margin.top})`);

            legend.append("line")
            .attr("x1", 0).attr("y1", 10)
            .attr("x2", 30).attr("y2", 10)
            .attr("stroke", lineColor)
            .attr("stroke-width", 2);

            legend.append("text")
            .attr("x", 40).attr("y", 14)
            .style("font-size", "12px")
            .text("Selected District");

            legend.append("line")
            .attr("x1", 0).attr("y1", 30)
            .attr("x2", 30).attr("y2", 30)
            .attr("stroke", "#444")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5,5");

            legend.append("text")
            .attr("x", 40).attr("y", 34)
            .style("font-size", "12px")
            .text("Average (All Districts)");

        }


  </script>
</body>

</html>
